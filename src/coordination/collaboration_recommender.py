"""
Collaboration Recommender - Recomendador de Colabora√ß√£o.

Transforma conex√µes detectadas em insights acion√°veis:
- Sugere quem deve falar com quem
- Identifica bloqueios urgentes
- Forma times/squads
- Gera mensagens prontas para envio
"""

import logging
from typing import List, Dict, Optional
from dataclasses import dataclass
from enum import Enum

from .connection_detector import Connection, ConnectionType

logger = logging.getLogger(__name__)


class RecommendationPriority(Enum):
    """Prioridade da recomenda√ß√£o."""
    CRITICAL = "critical"  # Bloqueio ativo
    HIGH = "high"  # Colabora√ß√£o importante
    MEDIUM = "medium"  # Sugest√£o √∫til
    LOW = "low"  # Opcional


@dataclass
class Recommendation:
    """Recomenda√ß√£o de colabora√ß√£o."""
    priority: RecommendationPriority
    target_person: str  # Para quem enviar
    message: str  # Mensagem pronta
    action_type: str  # Tipo de a√ß√£o (ex: "pair", "unblock", "coordinate")
    involves: List[str]  # Outras pessoas envolvidas
    connection: Connection  # Conex√£o original


class CollaborationRecommender:
    """
    Recomendador de colabora√ß√£o.

    Transforma conex√µes em insights acion√°veis
    e mensagens prontas para envio.
    """

    def __init__(self, connection_detector=None):
        """
        Inicializa recomendador.

        Args:
            connection_detector: ConnectionDetector
        """
        self.connection_detector = connection_detector
        logger.info("CollaborationRecommender inicializado")

    def generate_all_recommendations(self) -> List[Recommendation]:
        """
        Gera TODAS as recomenda√ß√µes de colabora√ß√£o.

        Returns:
            Lista de Recommendation ordenadas por prioridade
        """
        if not self.connection_detector:
            logger.error("ConnectionDetector n√£o configurado")
            return []

        # Detecta todas as conex√µes
        connections = self.connection_detector.detect_all_connections()

        logger.info(f"Processando {len(connections)} conex√µes...")

        recommendations = []

        for connection in connections:
            # Gera recomenda√ß√£o baseada no tipo de conex√£o
            recs = self._generate_recommendations_for_connection(connection)
            recommendations.extend(recs)

        # Ordena por prioridade
        priority_order = {
            RecommendationPriority.CRITICAL: 0,
            RecommendationPriority.HIGH: 1,
            RecommendationPriority.MEDIUM: 2,
            RecommendationPriority.LOW: 3
        }
        recommendations.sort(key=lambda r: priority_order[r.priority])

        logger.info(f"Geradas {len(recommendations)} recomenda√ß√µes")
        return recommendations

    def get_recommendations_for_person(
        self,
        person_name: str,
        priority_filter: Optional[RecommendationPriority] = None
    ) -> List[Recommendation]:
        """
        Pega recomenda√ß√µes para uma pessoa espec√≠fica.

        Args:
            person_name: Nome da pessoa
            priority_filter: Filtrar por prioridade (opcional)

        Returns:
            Lista de recomenda√ß√µes para essa pessoa
        """
        all_recs = self.generate_all_recommendations()

        recs = [
            rec for rec in all_recs
            if rec.target_person == person_name
        ]

        if priority_filter:
            recs = [rec for rec in recs if rec.priority == priority_filter]

        return recs

    def get_critical_recommendations(self) -> List[Recommendation]:
        """
        Pega apenas recomenda√ß√µes cr√≠ticas (bloqueios ativos).

        Returns:
            Lista de recomenda√ß√µes cr√≠ticas
        """
        all_recs = self.generate_all_recommendations()

        return [
            rec for rec in all_recs
            if rec.priority == RecommendationPriority.CRITICAL
        ]

    def _generate_recommendations_for_connection(
        self,
        connection: Connection
    ) -> List[Recommendation]:
        """
        Gera recomenda√ß√µes para uma conex√£o espec√≠fica.

        Args:
            connection: Conex√£o detectada

        Returns:
            Lista de 1-2 recomenda√ß√µes (uma para cada pessoa)
        """
        recommendations = []

        if connection.connection_type == ConnectionType.BLOCKER_DEPENDENCY:
            # BLOQUEIO: Gera recomenda√ß√£o CR√çTICA
            recommendations.extend(self._gen_blocker_recommendations(connection))

        elif connection.connection_type == ConnectionType.RELATED_TASKS:
            # TASKS RELACIONADAS: Sugere pair/review
            recommendations.extend(self._gen_pair_recommendations(connection))

        elif connection.connection_type == ConnectionType.SAME_PROJECT:
            # MESMO PROJETO: Sugere coordena√ß√£o
            recommendations.extend(self._gen_coordination_recommendations(connection))

        return recommendations

    def _gen_blocker_recommendations(self, connection: Connection) -> List[Recommendation]:
        """Gera recomenda√ß√µes para bloqueios."""
        recommendations = []

        # Determina quem √© bloqueador e quem √© bloqueado
        # (connection.reason cont√©m essa info)
        blocker = connection.person_a
        blocked = connection.person_b

        # Detecta se bloqueio ainda est√° ativo
        is_active_block = "üö®" in connection.suggested_action

        if is_active_block:
            # Recomenda√ß√£o CR√çTICA para o BLOQUEADOR
            message_blocker = (
                f"üö® URGENTE: Bloqueio Ativo\n\n"
                f"{blocked} est√° BLOQUEADO esperando voc√™ concluir uma task.\n\n"
                f"{connection.reason}\n\n"
                f"A√ß√£o: {connection.suggested_action}\n\n"
                f"Priorize isso! O time t√° parado."
            )

            recommendations.append(Recommendation(
                priority=RecommendationPriority.CRITICAL,
                target_person=blocker,
                message=message_blocker,
                action_type="unblock",
                involves=[blocked],
                connection=connection
            ))

            # Recomenda√ß√£o HIGH para o BLOQUEADO
            message_blocked = (
                f"‚è∏Ô∏è Voc√™ est√° bloqueado\n\n"
                f"{connection.reason}\n\n"
                f"Enquanto isso, voc√™ pode:\n"
                f"‚Ä¢ Trabalhar em outras tasks\n"
                f"‚Ä¢ Preparar o que vem depois\n"
                f"‚Ä¢ Falar com {blocker} pra ajudar\n\n"
                f"J√° avisei {blocker} que √© urgente! üö®"
            )

            recommendations.append(Recommendation(
                priority=RecommendationPriority.HIGH,
                target_person=blocked,
                message=message_blocked,
                action_type="wait_or_help",
                involves=[blocker],
                connection=connection
            ))

        else:
            # Bloqueio resolvido - apenas notifica
            message_blocked = (
                f"‚úÖ Bloqueio Resolvido!\n\n"
                f"{blocker} concluiu a task que te bloqueava.\n\n"
                f"Voc√™ pode continuar agora! üöÄ"
            )

            recommendations.append(Recommendation(
                priority=RecommendationPriority.MEDIUM,
                target_person=blocked,
                message=message_blocked,
                action_type="unblocked",
                involves=[blocker],
                connection=connection
            ))

        return recommendations

    def _gen_pair_recommendations(self, connection: Connection) -> List[Recommendation]:
        """Gera recomenda√ß√µes para pair programming/review."""
        recommendations = []

        person_a = connection.person_a
        person_b = connection.person_b

        # Mensagem para A sugerindo pair com B
        message_a = (
            f"üí° Sugest√£o: Pair Programming\n\n"
            f"{connection.reason}\n\n"
            f"Voc√™s dois est√£o trabalhando em tasks complementares.\n"
            f"Que tal fazer um pair ou review m√∫tuo?\n\n"
            f"Benef√≠cios:\n"
            f"‚Ä¢ Acelera ambas tasks\n"
            f"‚Ä¢ Compartilha conhecimento\n"
            f"‚Ä¢ Evita retrabalho\n\n"
            f"Quer que eu conecte voc√™s?"
        )

        recommendations.append(Recommendation(
            priority=RecommendationPriority.HIGH,
            target_person=person_a,
            message=message_a,
            action_type="pair",
            involves=[person_b],
            connection=connection
        ))

        # Mesma mensagem para B
        message_b = (
            f"üí° Sugest√£o: Pair Programming\n\n"
            f"{connection.reason}\n\n"
            f"Voc√™s dois est√£o trabalhando em tasks complementares.\n"
            f"Que tal fazer um pair ou review m√∫tuo?\n\n"
            f"Benef√≠cios:\n"
            f"‚Ä¢ Acelera ambas tasks\n"
            f"‚Ä¢ Compartilha conhecimento\n"
            f"‚Ä¢ Evita retrabalho\n\n"
            f"Quer que eu conecte voc√™s?"
        )

        recommendations.append(Recommendation(
            priority=RecommendationPriority.HIGH,
            target_person=person_b,
            message=message_b,
            action_type="pair",
            involves=[person_a],
            connection=connection
        ))

        return recommendations

    def _gen_coordination_recommendations(self, connection: Connection) -> List[Recommendation]:
        """Gera recomenda√ß√µes para coordena√ß√£o de projeto."""
        recommendations = []

        person_a = connection.person_a
        person_b = connection.person_b

        # Mensagem sugerindo coordena√ß√£o
        message = (
            f"ü§ù Coordena√ß√£o de Projeto\n\n"
            f"{connection.reason}\n\n"
            f"Sugest√£o: Alinhar esfor√ßos com {person_b}.\n\n"
            f"‚Ä¢ Garantir que n√£o est√£o fazendo trabalho duplicado\n"
            f"‚Ä¢ Dividir tasks de forma eficiente\n"
            f"‚Ä¢ Combinar deadlines\n\n"
            f"A√ß√£o: {connection.suggested_action}"
        )

        recommendations.append(Recommendation(
            priority=RecommendationPriority.MEDIUM,
            target_person=person_a,
            message=message,
            action_type="coordinate",
            involves=[person_b],
            connection=connection
        ))

        return recommendations

    def generate_team_insights(self) -> str:
        """
        Gera insights gerais sobre o time todo.

        Returns:
            String com resumo geral
        """
        recommendations = self.generate_all_recommendations()

        critical_count = len([r for r in recommendations if r.priority == RecommendationPriority.CRITICAL])
        high_count = len([r for r in recommendations if r.priority == RecommendationPriority.HIGH])

        # Conta pessoas envolvidas
        all_people = set()
        for rec in recommendations:
            all_people.add(rec.target_person)
            all_people.update(rec.involves)

        # Conta tipos de a√ß√£o
        action_types = {}
        for rec in recommendations:
            action_types[rec.action_type] = action_types.get(rec.action_type, 0) + 1

        insights = (
            f"üìä VIS√ÉO GERAL DO TIME\n"
            f"{'='*50}\n\n"
            f"üë• Pessoas envolvidas: {len(all_people)}\n"
            f"üö® Bloqueios cr√≠ticos: {critical_count}\n"
            f"‚ö° Colabora√ß√µes sugeridas: {high_count}\n\n"
            f"üìà Tipos de a√ß√£o recomendados:\n"
        )

        for action_type, count in sorted(action_types.items(), key=lambda x: x[1], reverse=True):
            insights += f"  ‚Ä¢ {action_type}: {count}\n"

        return insights
