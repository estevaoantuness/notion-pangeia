"""
Comunicador Emp√°tico - Empathetic Communicator.

Este m√≥dulo gera mensagens calibradas psicologicamente usando:
- Entrevista Motivacional (OARS): Open questions, Affirming, Reflections, Summaries
- Comunica√ß√£o N√£o-Violenta (OFNR): Observation, Feeling, Need, Request
- Refor√ßo Positivo

"""

import logging
import random
import yaml
from pathlib import Path
from typing import Dict, List, Optional
from .engine import PsychologicalMetrics, EmotionalState, EnergyLevel

logger = logging.getLogger(__name__)


class EmpatheticCommunicator:
    """
    Gera mensagens emp√°ticas baseadas no estado psicol√≥gico da pessoa.
    """

    def __init__(self, responses_file: Optional[str] = None):
        """
        Inicializa o comunicador emp√°tico.

        Args:
            responses_file: Caminho para arquivo YAML de respostas
        """
        if responses_file is None:
            responses_file = Path(__file__).parent.parent.parent / "config" / "psychology" / "psychological_responses.yaml"

        self.responses = self._load_responses(responses_file)
        logger.info("Empathetic Communicator inicializado")

    def _load_responses(self, file_path: Path) -> Dict:
        """Carrega respostas do arquivo YAML."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f)
        except Exception as e:
            logger.error(f"Erro ao carregar respostas: {e}")
            return {}

    def generate_task_completion_message(
        self,
        name: str,
        task_name: str,
        metrics: PsychologicalMetrics,
        is_first_today: bool = False,
        is_last_today: bool = False
    ) -> str:
        """
        Gera mensagem de celebra√ß√£o de tarefa conclu√≠da.

        Args:
            name: Nome da pessoa
            task_name: Nome da tarefa
            metrics: M√©tricas psicol√≥gicas
            is_first_today: Se √© a primeira do dia
            is_last_today: Se √© a √∫ltima do dia

        Returns:
            Mensagem personalizada
        """
        messages = []

        # Mensagem principal de conclus√£o
        template = random.choice(
            self.responses.get("encouragement", {}).get("task_completed", [])
        )
        messages.append(template.format(name=name, task_name=task_name))

        # Se for primeira do dia
        if is_first_today:
            first_msg = random.choice(
                self.responses.get("encouragement", {}).get("first_task_of_day", [])
            )
            messages.append(first_msg.format(name=name))

        # Se for √∫ltima do dia (todas conclu√≠das)
        if is_last_today:
            last_msg = random.choice(
                self.responses.get("encouragement", {}).get("last_task_completed", [])
            )
            messages.append(last_msg.format(name=name))

        # Se tiver sequ√™ncia (streak)
        if metrics.streak_days > 3:
            streak_msg = random.choice(
                self.responses.get("encouragement", {}).get("streak_recognition", [])
            )
            messages.append(streak_msg.format(name=name, days=metrics.streak_days))

        return "\n\n".join(messages)

    def generate_task_blocked_message(
        self,
        name: str,
        task_name: str,
        metrics: PsychologicalMetrics
    ) -> str:
        """
        Gera mensagem emp√°tica quando tarefa √© bloqueada.

        Args:
            name: Nome da pessoa
            task_name: Nome da tarefa bloqueada
            metrics: M√©tricas psicol√≥gicas

        Returns:
            Mensagem emp√°tica
        """
        # Escolher tom baseado no estado emocional
        if metrics.emotional_state in [EmotionalState.STRESSED, EmotionalState.OVERWHELMED]:
            # Tom mais suave e suportivo
            template = random.choice(
                self.responses.get("empathy", {}).get("task_blocked", [])[-2:]  # √öltimas 2 (mais suaves)
            )
        else:
            template = random.choice(
                self.responses.get("empathy", {}).get("task_blocked", [])
            )

        return template.format(name=name, task=task_name)

    def generate_check_in_message(
        self,
        name: str,
        period: str,  # "morning", "afternoon", "evening"
        metrics: PsychologicalMetrics,
        tasks: Optional[List[str]] = None
    ) -> str:
        """
        Gera mensagem de check-in personalizada.

        Args:
            name: Nome da pessoa
            period: Per√≠odo do dia
            metrics: M√©tricas psicol√≥gicas
            tasks: Lista de tarefas (opcional)

        Returns:
            Mensagem de check-in
        """
        messages = []

        # Sauda√ß√£o apropriada ao per√≠odo
        greeting = random.choice(
            self.responses.get("check_in", {}).get(period, {}).get("greeting", [])
        )
        messages.append(greeting.format(name=name))

        # Verifica√ß√£o de energia (manh√£)
        if period == "morning":
            energy_check = random.choice(
                self.responses.get("check_in", {}).get("morning", {}).get("energy_check", [])
            )
            messages.append(energy_check)

            # Introduzir tarefas
            if tasks:
                task_intro = random.choice(
                    self.responses.get("check_in", {}).get("morning", {}).get("task_intro", [])
                )
                messages.append(task_intro)

                # Listar tarefas
                messages.append(self._format_task_list(tasks))

                # Dar autonomia na escolha
                autonomy_msg = random.choice(
                    self.responses.get("autonomy", {}).get("task_order", [])
                )
                messages.append(autonomy_msg.format(name=name, n=len(tasks)))

        # Check de progresso (tarde)
        elif period == "afternoon":
            progress_msg = random.choice(
                self.responses.get("check_in", {}).get("afternoon", {}).get("progress_check", [])
            )
            messages.append(progress_msg)

            # Reconhecer progresso se houver
            if metrics.tasks_completed_today > 0:
                messages.append(
                    f"\nüìä Progresso: {metrics.tasks_completed_today} tarefas conclu√≠das!"
                )

            # Oferecer suporte
            support = random.choice(
                self.responses.get("check_in", {}).get("afternoon", {}).get("support_offer", [])
            )
            messages.append(support)

        # Reflex√£o (noite)
        elif period == "evening":
            reflection_intro = random.choice(
                self.responses.get("check_in", {}).get("evening", {}).get("reflection_intro", [])
            )
            messages.append(reflection_intro)

            # Perguntas de reflex√£o
            messages.append("")
            victory_q = random.choice(
                self.responses.get("reflection", {}).get("victory_question", [])
            )
            messages.append(f"1. {victory_q.format(name=name)}")

            learning_q = random.choice(
                self.responses.get("reflection", {}).get("learning_question", [])
            )
            messages.append(f"2. {learning_q}")

            tomorrow_q = random.choice(
                self.responses.get("reflection", {}).get("tomorrow_question", [])
            )
            messages.append(f"3. {tomorrow_q}")

            messages.append("")
            messages.append("N√£o precisa ser perfeito, s√≥ honesto üíô")

        return "\n\n".join(messages)

    def generate_intervention_message(
        self,
        name: str,
        metrics: PsychologicalMetrics,
        intervention_type: str = "burnout"
    ) -> str:
        """
        Gera mensagem de interven√ß√£o quando detecta problemas.

        Args:
            name: Nome da pessoa
            metrics: M√©tricas psicol√≥gicas
            intervention_type: Tipo de interven√ß√£o (burnout, overload, etc)

        Returns:
            Mensagem de interven√ß√£o
        """
        messages = []

        if intervention_type == "burnout":
            warning = random.choice(
                self.responses.get("intervention", {}).get("burnout_warning", [])
            )
            messages.append(warning.format(name=name))

        elif intervention_type == "overload":
            overload_msg = random.choice(
                self.responses.get("empathy", {}).get("overload_detected", [])
            )
            messages.append(overload_msg.format(name=name))

        # Oferecer ajuda espec√≠fica
        messages.append("\nPosso ajudar voc√™ a:")

        if metrics.tasks_pending > 8:
            messages.append("1. Priorizar s√≥ as 3 tarefas mais importantes")

        if metrics.tasks_blocked > 2:
            messages.append("2. Desbloquear algumas tarefas")

        messages.append("3. Reorganizar sua semana")
        messages.append("4. Redistribuir algumas tarefas")

        # Mensagem de suporte
        help_msg = random.choice(
            self.responses.get("intervention", {}).get("help_offer", [])
        )
        messages.append(f"\n{help_msg.format(name=name)}")

        return "\n".join(messages)

    def generate_positive_reinforcement(
        self,
        name: str,
        metrics: PsychologicalMetrics,
        achievement_type: str = "consistency"
    ) -> str:
        """
        Gera refor√ßo positivo baseado em conquistas.

        Args:
            name: Nome da pessoa
            metrics: M√©tricas psicol√≥gicas
            achievement_type: Tipo de conquista (consistency, quality, etc)

        Returns:
            Mensagem de refor√ßo positivo
        """
        template = random.choice(
            self.responses.get("positive_reinforcement", {}).get(achievement_type, [])
        )

        message = template.format(name=name)

        # Adicionar dados espec√≠ficos
        if achievement_type == "consistency" and metrics.streak_days > 0:
            message += f"\n\nVoc√™ est√° em uma sequ√™ncia de {metrics.streak_days} dias!"

        if metrics.completion_rate > 0.8:
            message += f"\n\nSua taxa de conclus√£o √© de {metrics.completion_rate * 100:.0f}%!"

        return message

    def generate_autonomy_message(
        self,
        name: str,
        context: str = "task_order"
    ) -> str:
        """
        Gera mensagem que promove autonomia.

        Args:
            name: Nome da pessoa
            context: Contexto (task_order, timing, approach, etc)

        Returns:
            Mensagem que d√° escolha
        """
        template = random.choice(
            self.responses.get("autonomy", {}).get(context, [])
        )

        return template.format(name=name)

    def generate_competence_recognition(
        self,
        name: str,
        skill: str,
        metrics: PsychologicalMetrics
    ) -> str:
        """
        Gera reconhecimento de compet√™ncia.

        Args:
            name: Nome da pessoa
            skill: Habilidade a reconhecer
            metrics: M√©tricas psicol√≥gicas

        Returns:
            Mensagem de reconhecimento
        """
        template = random.choice(
            self.responses.get("competence", {}).get("skill_recognition", [])
        )

        return template.format(name=name, skill=skill)

    def generate_team_impact_message(
        self,
        name: str,
        task_name: str
    ) -> str:
        """
        Gera mensagem destacando impacto no time (relacionamento).

        Args:
            name: Nome da pessoa
            task_name: Nome da tarefa

        Returns:
            Mensagem de impacto no time
        """
        template = random.choice(
            self.responses.get("relatedness", {}).get("team_impact", [])
        )

        return template.format(name=name, task=task_name)

    def adapt_tone_to_energy(
        self,
        message: str,
        energy_level: EnergyLevel
    ) -> str:
        """
        Adapta o tom da mensagem ao n√≠vel de energia.

        Args:
            message: Mensagem original
            energy_level: N√≠vel de energia detectado

        Returns:
            Mensagem com tom adaptado
        """
        # Se energia est√° baixa, remover emojis muito animados
        if energy_level in [EnergyLevel.LOW, EnergyLevel.VERY_LOW]:
            message = message.replace("üéâ", "‚úÖ")
            message = message.replace("üöÄ", "üí™")
            message = message.replace("‚ö°", "üëç")

        # Se energia est√° alta, pode adicionar mais entusiasmo
        elif energy_level == EnergyLevel.VERY_HIGH:
            # Adicionar um emoji extra de vez em quando
            if random.random() < 0.3:
                message += " üåü"

        return message

    def _format_task_list(self, tasks: List[str]) -> str:
        """
        Formata lista de tarefas de forma leg√≠vel.

        Args:
            tasks: Lista de tarefas

        Returns:
            String formatada
        """
        formatted_tasks = []
        for i, task in enumerate(tasks, 1):
            formatted_tasks.append(f"{i}. {task}")

        return "\n".join(formatted_tasks)

    def generate_oars_question(
        self,
        name: str,
        context: str,
        metrics: PsychologicalMetrics
    ) -> str:
        """
        Gera pergunta aberta (Open-ended) seguindo OARS.

        Args:
            name: Nome da pessoa
            context: Contexto da pergunta
            metrics: M√©tricas psicol√≥gicas

        Returns:
            Pergunta aberta
        """
        questions = {
            "feeling": [
                f"{name}, como voc√™ est√° se sentindo com suas tarefas hoje?",
                f"Como voc√™ se sente em rela√ß√£o ao seu dia, {name}?",
                f"{name}, o que est√° passando pela sua cabe√ßa agora?"
            ],
            "challenge": [
                f"{name}, qual √© o maior desafio que voc√™ est√° enfrentando?",
                f"O que est√° sendo mais dif√≠cil pra voc√™ agora, {name}?",
                f"{name}, que obst√°culo voc√™ gostaria de superar?"
            ],
            "goal": [
                f"{name}, o que voc√™ gostaria de alcan√ßar hoje?",
                f"Qual √© sua prioridade n√∫mero 1 agora, {name}?",
                f"{name}, como voc√™ quer que seu dia termine?"
            ],
            "support": [
                f"{name}, como eu posso te ajudar hoje?",
                f"Do que voc√™ precisa de mim agora, {name}?",
                f"{name}, o que faria sua vida mais f√°cil hoje?"
            ]
        }

        return random.choice(questions.get(context, questions["feeling"]))

    def generate_reflection_message(
        self,
        name: str,
        observation: str,
        metrics: PsychologicalMetrics
    ) -> str:
        """
        Gera reflex√£o (Reflection) seguindo OARS.

        Args:
            name: Nome da pessoa
            observation: O que foi observado
            metrics: M√©tricas psicol√≥gicas

        Returns:
            Mensagem de reflex√£o
        """
        reflections = [
            f"{name}, parece que {observation}.",
            f"Percebi que {observation}, {name}.",
            f"{name}, notei que {observation}."
        ]

        base = random.choice(reflections)

        # Adicionar valida√ß√£o/empatia
        validations = [
            " √â normal se sentir assim.",
            " Isso acontece com todo mundo.",
            " Voc√™ n√£o est√° sozinho(a) nisso.",
            ""
        ]

        return base + random.choice(validations)

    def generate_summary_message(
        self,
        name: str,
        achievements: List[str],
        metrics: PsychologicalMetrics
    ) -> str:
        """
        Gera resumo (Summary) seguindo OARS.

        Args:
            name: Nome da pessoa
            achievements: Lista de conquistas
            metrics: M√©tricas psicol√≥gicas

        Returns:
            Mensagem de resumo
        """
        intro = f"Ent√£o, {name}, deixa eu recapitular:\n\n"

        summary_items = []
        for achievement in achievements:
            summary_items.append(f"‚úÖ {achievement}")

        summary = "\n".join(summary_items)

        # Afirma√ß√£o final
        affirmations = [
            "\n\nIsso √© muito bom! Continue assim!",
            "\n\nVoc√™ est√° indo muito bem!",
            "\n\nEstou impressionado(a) com seu progresso!",
            "\n\nEsse √© o caminho! Parab√©ns!"
        ]

        return intro + summary + random.choice(affirmations)
