"""
Cliente Twilio para envio e recebimento de mensagens via WhatsApp.

Este m√≥dulo fornece interface para interagir com a API do Twilio WhatsApp,
incluindo envio de mensagens com retry logic.
"""

import logging
import time
from typing import Optional, Tuple
from twilio.rest import Client as TwilioClient
from twilio.base.exceptions import TwilioRestException

from config.settings import settings

logger = logging.getLogger(__name__)


class WhatsAppClient:
    """
    Cliente para interagir com WhatsApp via Twilio.

    Gerencia envio de mensagens, valida√ß√£o de n√∫meros e tratamento de erros.
    """

    def __init__(
        self,
        account_sid: Optional[str] = None,
        auth_token: Optional[str] = None,
        from_number: Optional[str] = None
    ):
        """
        Inicializa o cliente WhatsApp.

        Args:
            account_sid: Twilio Account SID (usa settings se n√£o fornecido)
            auth_token: Twilio Auth Token (usa settings se n√£o fornecido)
            from_number: N√∫mero WhatsApp do bot (usa settings se n√£o fornecido)
        """
        self.account_sid = account_sid or settings.TWILIO_ACCOUNT_SID
        self.auth_token = auth_token or settings.TWILIO_AUTH_TOKEN
        self.from_number = from_number or settings.TWILIO_WHATSAPP_NUMBER

        self.client = TwilioClient(self.account_sid, self.auth_token)
        logger.info("Cliente WhatsApp inicializado")

    def validate_number(self, number: str) -> Tuple[bool, str]:
        """
        Valida formato de n√∫mero WhatsApp.

        Args:
            number: N√∫mero a validar (deve iniciar com whatsapp:+)

        Returns:
            Tuple[bool, str]: (is_valid, message)
        """
        if not number.startswith("whatsapp:+"):
            return False, f"N√∫mero inv√°lido: {number}. Deve iniciar com 'whatsapp:+'"

        if len(number) < 15:  # whatsapp:+ + pelo menos 10 d√≠gitos
            return False, f"N√∫mero muito curto: {number}"

        return True, "N√∫mero v√°lido"

    def send_message(
        self,
        to_number: str,
        message: str,
        retry_count: int = 0
    ) -> Tuple[bool, Optional[str], Optional[str]]:
        """
        Envia mensagem via WhatsApp com retry logic.

        Args:
            to_number: N√∫mero de destino (formato: whatsapp:+XXXXXXXXXXX)
            message: Texto da mensagem
            retry_count: Contador de tentativas (interno)

        Returns:
            Tuple[bool, Optional[str], Optional[str]]:
                (sucesso, message_sid, erro)
        """
        # Valida n√∫mero
        is_valid, validation_msg = self.validate_number(to_number)
        if not is_valid:
            logger.error(validation_msg)
            return False, None, validation_msg

        try:
            # Envia mensagem
            message_obj = self.client.messages.create(
                from_=self.from_number,
                to=to_number,
                body=message
            )

            logger.info(
                f"‚úÖ Mensagem enviada para {to_number}. "
                f"SID: {message_obj.sid}, Status: {message_obj.status}"
            )

            return True, message_obj.sid, None

        except TwilioRestException as e:
            error_msg = f"Erro Twilio {e.code}: {e.msg}"

            # Se for erro recuper√°vel e ainda tem tentativas, retry
            recoverable_codes = [20429, 20003, 20500]  # Rate limit, Auth error, Server error
            if e.code in recoverable_codes and retry_count < settings.MAX_RETRIES:
                wait_time = (2 ** retry_count) * 2  # Backoff exponencial (2, 4, 8 segundos)
                logger.warning(
                    f"‚ö†Ô∏è {error_msg}. "
                    f"Tentando novamente em {wait_time}s "
                    f"(tentativa {retry_count + 1}/{settings.MAX_RETRIES})"
                )
                time.sleep(wait_time)
                return self.send_message(to_number, message, retry_count + 1)

            logger.error(f"‚ùå {error_msg}")
            return False, None, error_msg

        except Exception as e:
            error_msg = f"Erro inesperado: {str(e)}"
            logger.error(f"‚ùå {error_msg}")
            return False, None, error_msg

    def send_bulk_messages(
        self,
        recipients: list[tuple[str, str]]
    ) -> dict[str, dict]:
        """
        Envia mensagens para m√∫ltiplos destinat√°rios.

        Args:
            recipients: Lista de tuplas (numero, mensagem)

        Returns:
            Dict com resultados: {numero: {success, sid, error}}
        """
        results = {}

        for to_number, message in recipients:
            success, sid, error = self.send_message(to_number, message)

            results[to_number] = {
                "success": success,
                "sid": sid,
                "error": error
            }

            # Pequena pausa entre mensagens para evitar rate limit
            time.sleep(0.5)

        successful = sum(1 for r in results.values() if r["success"])
        failed = len(results) - successful

        logger.info(
            f"üìä Envio em lote conclu√≠do: "
            f"{successful} sucessos, {failed} falhas"
        )

        return results

    def get_message_status(self, message_sid: str) -> Optional[dict]:
        """
        Consulta status de uma mensagem enviada.

        Args:
            message_sid: SID da mensagem

        Returns:
            Dict com informa√ß√µes da mensagem ou None se erro
        """
        try:
            message = self.client.messages(message_sid).fetch()

            return {
                "sid": message.sid,
                "status": message.status,
                "to": message.to,
                "from": message.from_,
                "body": message.body,
                "date_sent": message.date_sent,
                "error_code": message.error_code,
                "error_message": message.error_message
            }

        except TwilioRestException as e:
            logger.error(f"Erro ao buscar status da mensagem {message_sid}: {e}")
            return None

    def test_connection(self) -> Tuple[bool, str]:
        """
        Testa conex√£o com API Twilio.

        Returns:
            Tuple[bool, str]: (sucesso, mensagem)
        """
        try:
            # Tenta buscar informa√ß√µes da conta
            account = self.client.api.accounts(self.account_sid).fetch()

            logger.info(f"‚úÖ Conex√£o com Twilio OK! Conta: {account.friendly_name}")
            return True, f"Conectado √† conta Twilio: {account.friendly_name}"

        except TwilioRestException as e:
            error_msg = f"Erro ao conectar com Twilio: {e.code} - {e.msg}"
            logger.error(f"‚ùå {error_msg}")
            return False, error_msg

        except Exception as e:
            error_msg = f"Erro inesperado: {str(e)}"
            logger.error(f"‚ùå {error_msg}")
            return False, error_msg


def format_phone_number(phone: str) -> str:
    """
    Formata n√∫mero de telefone para formato WhatsApp Twilio.

    Args:
        phone: N√∫mero no formato +55XXXXXXXXXXX ou 55XXXXXXXXXXX

    Returns:
        N√∫mero formatado: whatsapp:+55XXXXXXXXXXX
    """
    # Remove espa√ßos e caracteres especiais
    phone = ''.join(filter(str.isdigit, phone))

    # Adiciona + se n√£o tiver
    if not phone.startswith('+'):
        phone = '+' + phone

    # Adiciona prefixo whatsapp:
    if not phone.startswith('whatsapp:'):
        phone = 'whatsapp:' + phone

    return phone
